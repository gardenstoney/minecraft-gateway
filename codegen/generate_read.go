//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

type generatedStruct struct {
	Name   string
	Fields []string
}

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: go run generate_reads.go -- path/to/dir")
		os.Exit(1)
	}

	fset := token.NewFileSet()
	var structs []generatedStruct
	var pkgName string

	files, _ := filepath.Glob(filepath.Join(filepath.Dir(os.Args[2]), "*.go"))

	for _, file := range files {
		node, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		if pkgName == "" {
			pkgName = node.Name.Name
		}

		// Walk through top-level declarations
		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)

			// filter for only type declarations
			if !ok || gen.Tok != token.TYPE || gen.Doc == nil {
				continue
			}

			// filter for types with @gen:read in doc comment
			if !strings.Contains(gen.Doc.Text(), "@gen:read") {
				continue
			}

			for _, spec := range gen.Specs {
				tspec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				// type assertion for struct type
				structType, ok := tspec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				var fieldNames []string
				for _, field := range structType.Fields.List {
					for _, name := range field.Names {
						fieldNames = append(fieldNames, name.Name)
					}
				}

				structs = append(structs, generatedStruct{
					Name:   tspec.Name.Name,
					Fields: fieldNames,
				})
			}
		}
	}

	// Output next to the first file provided
	outFile := filepath.Join(filepath.Dir(os.Args[2]), "zz_generated_reads.go")
	out, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer out.Close()

	fmt.Fprintf(out, "// Code generated by generate_reads.go; DO NOT EDIT.\n")
	fmt.Fprintf(out, "package %s\n\n", pkgName)
	fmt.Fprintf(out, "import \"bytes\"\n\n")

	for _, s := range structs {
		fmt.Fprintf(out, "func (p *%s) Read(r *bytes.Reader) error {\n", s.Name)
		for _, f := range s.Fields {
			fmt.Fprintf(out, "	if err := p.%s.Read(r); err != nil { return err }\n", f)
		}
		fmt.Fprintln(out, "	return nil\n}")
		fmt.Fprintln(out)
	}
}
